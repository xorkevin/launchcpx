#!/usr/bin/env bash

set -e

if [ -z $FLIGHTCTL_ROOT ]; then
  echo "Run flightctl"
  exit 1
fi

. "$FLIGHTCTL_ROOT/_flightctl_lib.sh"

usage() {
  cat <<EOF 1>&2
USAGE:
    $BIN_NAME [OPTIONS] <pgns> <pgname> <name>

OPTIONS:
    -n <namespace>
        Use the kubernetes namespace.
        Default is default.
    -t <ttl>
        Time to live duration of vault kube role token.
        Default is 1h.
    -m <maxttl>
        Max time to live duration of vault kube role token.
        Default is 24h.
    -o <directory>
        Output config to directory.
        Default is the current directory.
    -h
        Print this help.

ARGS:
    <pgns>
        The name of the postgres service namespace.
    <pgname>
        The name of the postgres service.
    <name>
        The name of the application.
EOF
}

usage_exit() {
  usage
  exit 2
}

ns=default
ttl='1h'
maxttl='24h'
outdir=.
pgns=
pgname=
name=

while getopts ':n:t:o:h' opt; do
  case $opt in
    n) ns="$OPTARG";;
    t) ttl="$OPTARG";;
    o) outdir="$OPTARG";;
    h) usage; exit 0;;
    *) usage_exit;;
  esac
done
shift $(($OPTIND - 1))
pgns="$1"
pgname="$2"
name="$3"

# validation
if [ -z $pgns ]; then
  usage_exit
fi
if [ -z $pgname ]; then
  usage_exit
fi
if [ -z $name ]; then
  usage_exit
fi

policydir=${outdir}/policy
mkdir -p $policydir

config=${pgns}-${pgname}
role=${config}-role
rolereadonly=${config}-readonly

outfile=${policydir}/${config}.policy.hcl
exec 3>$outfile

(
cat <<EOF
path "database/creds/${role}" {
  capabilities = ["read"]
}
path "database/creds/${rolereadonly}" {
  capabilities = ["read"]
}
EOF
) 1>&3

exec 3>&-

connect_write_app_policy $policydir $ns $name
connect_write_kube_role $ns $name $ttl $maxttl
